
// ####################################################################################################################
:sectnums:
== NEORV32 Processor (SoC)

The NEORV32 Processor is based on the NEORV32 CPU. Together with common peripheral
interfaces and embedded memories it provides a RISC-V-based full-scale microcontroller-like SoC platform.

image::neorv32_processor.png[align=center]

**Section Structure**

* <<_processor_top_entity_signals>> and <<_processor_top_entity_generics>>
* <<_processor_clocking>> and <<_processor_reset>>
* <<_processor_interrupts>>
* <<_address_space>> and <<_boot_configuration>>
* <<_processor_internal_modules>>

**Key Features**

* _optional_ processor-internal data and instruction memories (<<_data_memory_dmem,**DMEM**>>/<<_instruction_memory_imem,**IMEM**>>)
* _optional_ caches (<<_processor_internal_instruction_cache_icache,**iCACHE**>>/<<_processor_internal_data_cache_dcache,**dCACHE**>>)
* _optional_ internal bootloader (<<_bootloader_rom_bootrom,**BOOTROM**>>) with UART console & SPI flash boot option
* _optional_ machine system timer (<<_machine_system_timer_mtime,**MTIME**>>), RISC-V-compatible
* _optional_ two independent universal asynchronous receivers and transmitters (<<_primary_universal_asynchronous_receiver_and_transmitter_uart0,**UART0**>>,
<<_secondary_universal_asynchronous_receiver_and_transmitter_uart1,**UART1**>>) with optional hardware flow control (RTS/CTS)
* _optional_ serial peripheral interface host controller (<<_serial_peripheral_interface_controller_spi,**SPI**>>) with 8 dedicated CS lines
* _optional_ 8-bit serial data device interface (<<_serial_data_interface_controller_spi,**SDI**>>)
* _optional_ two wire serial interface controller (<<_two_wire_serial_interface_controller_twi,**TWI**>>), compatible to the IÂ²C standard
* _optional_ general purpose parallel IO port (<<_general_purpose_input_and_output_port_gpio,**GPIO**>>), 64xOut, 64xIn
* _optional_ 32-bit external bus interface, Wishbone b4 / AXI4-Lite compatible (<<_processor_external_memory_interface_wishbone_axi4_lite,**WISHBONE**>>)
* _optional_ watchdog timer (<<_watchdog_timer_wdt,**WDT**>>)
* _optional_ PWM controller with up to 12 channels & 8-bit duty cycle resolution (<<_pulse_width_modulation_controller_pwm,**PWM**>>)
* _optional_ ring-oscillator-based true random number generator (<<_true_random_number_generator_trng,**TRNG**>>)
* _optional_ custom functions subsystem for custom co-processor extensions (<<_custom_functions_subsystem_cfs,**CFS**>>)
* _optional_ NeoPixel(TM)/WS2812-compatible smart LED interface (<<_smart_led_interface_neoled,**NEOLED**>>)
* _optional_ external interrupt controller with up to 32 channels (<<_external_interrupt_controller_xirq,**XIRQ**>>)
* _optional_ general purpose 32-bit timer (<<_general_purpose_timer_gptmr,**GPTMR**>>)
* _optional_ execute in place module (<<_execute_in_place_module_xip,**XIP**>>)
* _optional_ 1-wire serial interface controller (<<_one_wire_serial_interface_controller_onewire,**ONEWIRE**>>), compatible to the 1-wire standard
* _optional_ on-chip debugger with JTAG TAP (<<_on_chip_debugger_ocd,**OCD**>>)
* bus keeper to monitor processor-internal bus transactions (<<_internal_bus_monitor_buskeeper,**BUSKEEPER**>>)
* system configuration information memory to check HW configuration via software (<<_system_configuration_information_memory_sysinfo,**SYSINFO**>>)


<<<
// ####################################################################################################################
:sectnums:
=== Processor Top Entity - Signals

The following table shows all interface signals of the processor top entity (`rtl/core/neorv32_top.vhd`).
All signals are of type `std_ulogic` or `std_ulogic_vector`, respectively.

.Default Values of Inputs
[NOTE]
All input signals provide default values in case they are not explicitly assigned during instantiation.

.Configurable Amount of Channels
[NOTE]
Some peripherals allow to configure the number of channels to-be-implemented by a generic (for example the number
of PWM channels). The according input/output signals have a fixed sized regardless of the actually configured
amount of channels. If less than the maximum number of channels is configured, only the LSB-aligned channels are used:
in case of an _input port_ the remaining bits/channels are left unconnected; in case of an _output port_ the remaining
bits/channels are hardwired to zero.

.Tri-State Interfaces
[NOTE]
Some interfaces (like the TWI and the 1-Wire bus) require tri-state drivers in the designs top module.


.NEORV32 Processor Signal List
[cols="<2,^1,^1,<8"]
[options="header",grid="rows"]
|=======================
| Name | Width | Direction | Description
4+^| **Global Control (<<_processor_clocking>> and <<_processor_reset>>)**
| `clk_i`       |  1 |  in | global clock line, all registers triggering on rising edge
| `rstn_i`      |  1 |  in | global reset, asynchronous, **low-active**
4+^| **JTAG Access Port for <<_on_chip_debugger_ocd>>**
| `jtag_trst_i` |  1 |  in | TAP reset, low-active (optional)
| `jtag_tck_i`  |  1 |  in | serial clock
| `jtag_tdi_i`  |  1 |  in | serial data input
| `jtag_tdo_o`  |  1 | out | serial data output
| `jtag_tms_i`  |  1 |  in | mode select
4+^| **<<_processor_external_memory_interface_wishbone>>**
| `wb_tag_o`    |  3 | out | tag (access type identifier)
| `wb_adr_o`    | 32 | out | destination address
| `wb_dat_i`    | 32 |  in | write data
| `wb_dat_o`    | 32 | out | read data
| `wb_we_o`     |  1 | out | write enable ('0' = read transfer)
| `wb_sel_o`    |  4 | out | byte enable
| `wb_stb_o`    |  1 | out | strobe
| `wb_cyc_o`    |  1 | out | valid cycle
| `wb_lock_o`   |  1 | out | exclusive access request
| `wb_ack_i`    |  1 |  in | transfer acknowledge
| `wb_err_i`    |  1 |  in | transfer error
4+^| **Advanced Memory Control Signals**
| `fence_o`     |  1 | out | indicates an executed _fence_ instruction
| `fencei_o`    |  1 | out | indicates an executed _fencei_ instruction
4+^| **<<_execute_in_place_module_xip>>**
| `xip_csn_o`   |  1 | out | chi select, low-active
| `xip_clk_o`   |  1 | out | serial clock
| `xip_dat_i`   |  1 |  in | serial data input
| `xip_dat_o`   |  1 | out | serial data output
4+^| **<<_general_purpose_input_and_output_port_gpio>>**
| `gpio_o`      | 64 | out | general purpose parallel output
| `gpio_i`      | 64 |  in | general purpose parallel input
4+^| **<<_primary_universal_asynchronous_receiver_and_transmitter_uart0>>**
| `uart0_txd_o` |  1 | out | serial transmitter
| `uart0_rxd_i` |  1 |  in | serial receiver
| `uart0_rts_o` |  1 | out | RX ready to receive new char
| `uart0_cts_i` |  1 |  in | TX allowed to start sending
4+^| **<<_secondary_universal_asynchronous_receiver_and_transmitter_uart1>>**
| `uart1_txd_o` |  1 | out | serial transmitter
| `uart1_rxd_i` |  1 |  in | serial receiver
| `uart1_rts_o` |  1 | out | RX ready to receive new char
| `uart1_cts_i` |  1 |  in | TX allowed to start sending
4+^| **<<_serial_peripheral_interface_controller_spi>>**
| `spi_clk_o`   |  1 | out | controller clock line
| `spi_dat_o`   |  1 | out | serial data output
| `spi_dat_i`   |  1 |  in | serial data input
| `spi_csn_o`   |  8 | out |  select (low-active)
4+^| **<<_serial_data_interface_controller_sdi>>**
| `sdi_clk_i`   |  1 |  in | controller clock line
| `sdi_dat_o`   |  1 | out | serial data output
| `sdi_dat_i`   |  1 |  in | serial data input
| `sdi_csn_i`   |  1 |  in | chip select (low-active)
4+^| **<<_two_wire_serial_interface_controller_twi>>**
| `twi_sda_i`   |  1 |  in | serial data line sense input
| `twi_sda_o`   |  1 | out | serial data line output (pull low only)
| `twi_scl_i`   |  1 |  in | serial clock line sense input
| `twi_scl_o`   |  1 | out | serial clock line output (pull low only)
4+^| **<<_one_wire_serial_interface_controller_onewire>>**
| `onewire_i`   |  1 |  in | 1-wire bus sense input
| `onewire_o`   |  1 | out | 1-wire bus output (pull low only)
4+^| **<<_pulse_width_modulation_controller_pwm>>**
| `pwm_o`       | 12 | out | pulse-width modulated channels
4+^| **<<_custom_functions_subsystem_cfs>>**
| `cfs_in_i`    | 32 |  in | custom CFS input signal conduit
| `cfs_out_o`   | 32 | out | custom CFS output signal conduit
4+^| **<<_smart_led_interface_neoled>>**
| `neoled_o`    |  1 | out | asynchronous serial data output
4+^| **<<_external_interrupt_controller_xirq>>**
| `xirq_i`      | 32 |  in | external interrupt requests
4+^| **RISC-V Machine-Mode <<_processor_interrupts>>**
| `mtime_irq_i` |  1 |  in | machine timer interrupt (RISC-V), high-level-active
| `msw_irq_i`   |  1 |  in | machine software interrupt (RISC-V), high-level-active
| `mext_irq_i`  |  1 |  in | machine external interrupt (RISC-V), high-level-active
|=======================


<<<
// ####################################################################################################################
:sectnums:
=== Processor Top Entity - Generics

This section lists all configuration generics of the NEORV32 processor top entity (`rtl/neorv32_top.vhd`).

.Customization
[TIP]
The NEORV32 generics allow to configure the system according to your needs. The generics are
used to control implementation of certain CPU extensions and peripheral modules and even allow to
optimize the system for certain design goals like minimal area or maximum performance.

.Software Discovery of Configuration
[TIP]
Software can determine the actual CPU configuration via the <<_misa>> and <<_mxisa>> CSRs. The Soc/Processor
and can be determined via the <<_system_configuration_information_memory_sysinfo, SYSINFO>> memory-mapped registers.

.Excluded Modules and Extensions
[NOTE]
If optional modules (like CPU extensions or peripheral devices) are not enabled the according hardware
will not be synthesized at all. Hence, the disabled modules do not increase area and power requirements
and do not impact timing.

.Configuration Check
[NOTE]
Not all configuration combinations are valid. The processor RTL code provides sanity checks to inform the user
during synthesis/simulation if an invalid combination has been detected. It is recommended to run a quick simulation
using the provided simulation/GHDL scripts to verify the configuration of the processor generics.

.Table Abbreviations
[NOTE]
The generic type "suv(x:y)" defines a `std_ulogic_vector(x downto y)`.


.NEORV32 Processor Generic List
[cols="<3,^2,^2,<8"]
[options="header",grid="rows"]
|=======================
| Name | Type | Default | Description
4+^| **General**
| `CLOCK_FREQUENCY`       | natural   | -          | The clock frequency of the processor's `clk_i` input port in Hertz (Hz).
| `INT_BOOTLOADER_EN`     | boolean   | false      | Implement the processor-internal <<_bootloader_rom_bootrom>>, pre-initialized with the default <<_bootloader>> image.
| `HART_ID`               | suv(31:0) | 0x00000000 | The hart thread ID of the CPU (passed to <<_mhartid>> CSRs).
| `VENDOR_ID`             | suv(31:0) | 0x00000000 | JEDEC ID (passed to <<_mvendorid>> CSRs).
| `CUSTOM_ID`             | suv(31:0) | 0x00000000 | User-defined identifier to identify a certain setup or to pass user-defined flags to software (via the <<_system_configuration_information_memory_sysinfo>>).
| `ON_CHIP_DEBUGGER_EN`   | boolean   | false      | Implement the on-chip debugger <<_on_chip_debugger_ocd>> and the CPU debug mode.
4+^| **CPU <<_instruction_sets_and_extensions>>**
| `CPU_EXTENSION_RISCV_B`        | boolean | false | Enable <<_b_isa_extension>> (bit-manipulation).
| `CPU_EXTENSION_RISCV_C`        | boolean | false | Enable <<_c_isa_extension>> (compressed instructions).
| `CPU_EXTENSION_RISCV_E`        | boolean | false | Enable <<_e_isa_extension>> (reduced register file size).
| `CPU_EXTENSION_RISCV_M`        | boolean | false | Enable <<_m_isa_extension>> (hardware-based integer multiplication and division).
| `CPU_EXTENSION_RISCV_U`        | boolean | false | Enable <<_u_isa_extension>> (less-privileged user mode).
| `CPU_EXTENSION_RISCV_Zfinx`    | boolean | false | Enable <<_zfinx_isa_extension>> (single-precision floating-point unit).
| `CPU_EXTENSION_RISCV_Zicntr`   | boolean | true  | Enable <<_zicntr_isa_extension>> (CPU base counters).
| `CPU_EXTENSION_RISCV_Zicond`   | boolean | false | Enable <<_zicond_isa_extension>> (conditional operations).
| `CPU_EXTENSION_RISCV_Zihpm`    | boolean | false | Enable <<_zihpm_isa_extension>> (hardware performance monitors).
| `CPU_EXTENSION_RISCV_Zifencei` | boolean | false | Enable <<_zifencei_isa_extension>> (instruction stream synchronization).
| `CPU_EXTENSION_RISCV_Zmmul`    | boolean | false | Enable <<_zmmul_isa_extension>> (hardware-based integer multiplication).
| `CPU_EXTENSION_RISCV_Zxcfu`    | boolean | false | Enable NEORV32-specific <<_zxcfu_isa_extension>> (custom RISC-V instructions).
4+^| **CPU Tuning Options**
| `FAST_MUL_EN`           | boolean   | false      | Implement fast (but large) full-parallel multipliers (trying to infer DSP blocks).
| `FAST_SHIFT_EN`         | boolean   | false      | Implement fast (bur large) pull-parallel barrel shifters.
| `CPU_IPB_ENTRIES`       | natural   | 1          | Number of entries in the CPU's instruction prefetch buffer.
4+^| **Physical Memory Protection (<<_pmp_isa_extension>>)**
| `PMP_NUM_REGIONS`       | natural   | 0          | Number of implemented PMP regions (0..16).
| `PMP_MIN_GRANULARITY`   | natural   | 4          | Minimal region granularity in bytes. Has to be a power of two, min 4.
4+^| **Hardware Performance Monitors (<<_zihpm_isa_extension>>)**
| `HPM_NUM_CNTS`          | natural   | 0          | Number of implemented hardware performance monitor counters (0..29).
| `HPM_CNT_WIDTH`         | natural   | 40         | Total LSB-aligned size of each HPM counter. Min 0, max 64.
4+^| **Internal <<_instruction_memory_imem>>**
| `MEM_INT_IMEM_EN`       | boolean   | false      | Implement the processor-internal instruction memory.
| `MEM_INT_IMEM_SIZE`     | natural   | 16*1024    | Size in bytes of the processor internal instruction memory.
4+^| **Internal <<_data_memory_dmem>>**
| `MEM_INT_DMEM_EN`       | boolean   | false      | Implement the processor-internal data memory.
| `MEM_INT_DMEM_SIZE`     | natural   | 8*1024     | Size in bytes of the processor-internal data memory.
4+^| **<<_processor_internal_instruction_cache_icache>>**
| `ICACHE_EN`             | boolean   | false      | Implement the instruction cache.
| `ICACHE_NUM_BLOCKS`     | natural   | 4          | Number of blocks ("pages" or "lines") Has to be a power of two.
| `ICACHE_BLOCK_SIZE`     | natural   | 64         | Size in bytes of each block. Has to be a power of two.
| `ICACHE_ASSOCIATIVITY`  | natural   | 1          | Associativity (number of sets). Allowed configurations: `1` = 1 set, direct mapped; `2` = 2-way set-associative.
4+^| **<<_processor_internal_data_cache_dcache>>**
| `DCACHE_EN`             | boolean   | false      | Implement the data cache.
| `DCACHE_NUM_BLOCKS`     | natural   | 4          | Number of blocks ("pages" or "lines") Has to be a power of two.
| `DCACHE_BLOCK_SIZE`     | natural   | 64         | Size in bytes of each block. Has to be a power of two.
4+^| **<<_processor_external_memory_interface_wishbone>>**
| `MEM_EXT_EN`            | boolean   | false      | Implement the external bus interface.
| `MEM_EXT_TIMEOUT`       | natural   | 255        | Clock cycles after which a pending external bus access will auto-terminate and raise a bus fault exception.
| `MEM_EXT_PIPE_MODE`     | boolean   | false      | Use _standard_ ("classic") Wishbone protocol when false. Use _pipelined_ Wishbone protocol when true.
| `MEM_EXT_BIG_ENDIAN`    | boolean   | false      | Use BIG endian data order interface for external bus.
| `MEM_EXT_ASYNC_RX`      | boolean   | false      | Disable input registers when true.
| `MEM_EXT_ASYNC_TX`      | boolean   | false      | Disable output registers when true.
4+^| **<<_external_interrupt_controller_xirq>>**
| `XIRQ_NUM_CH`           | natural   | 0          | Number of channels of the external interrupt controller. Valid values are 0..32.
| `XIRQ_TRIGGER_TYPE`     | suv(31:0) | 0xFFFFFFFF | Trigger type (one bit per channel): `0` = level-triggered, '1' = edge triggered.
| `XIRQ_TRIGGER_POLARITY` | suv(31:0) | 0xFFFFFFFF | Trigger polarity (one bit per channel): `0` = low-level/falling-edge, '1' = high-level/rising-edge.
4+^| **Peripheral/IO Modules**
| `IO_GPIO_NUM`           | natural   | 0          | Number of general purpose input/output pairs of the <<_general_purpose_input_and_output_port_gpio>>.
| `IO_MTIME_EN`           | boolean   | false      | Implement the <<_machine_system_timer_mtime>>.
| `IO_UART0_EN`           | boolean   | false      | Implement the <<_primary_universal_asynchronous_receiver_and_transmitter_uart0>>.
| `IO_UART0_RX_FIFO`      | natural   | 1          | UART0 RX FIFO depth, has to be a power of two, minimum value is 1, max 32768.
| `IO_UART0_TX_FIFO`      | natural   | 1          | UART0 TX FIFO depth, has to be a power of two, minimum value is 1, max 32768.
| `IO_UART1_EN`           | boolean   | false      | Implement the <<_secondary_universal_asynchronous_receiver_and_transmitter_uart1>>.
| `IO_UART1_RX_FIFO`      | natural   | 1          | UART1 RX FIFO depth, has to be a power of two, minimum value is 1, max 32768.
| `IO_UART1_TX_FIFO`      | natural   | 1          | UART1 TX FIFO depth, has to be a power of two, minimum value is 1, max 32768.
| `IO_SPI_EN`             | boolean   | false      | Implement the <<_serial_peripheral_interface_controller_spi>>.
| `IO_SPI_FIFO`           | natural   | 1          | Depth of the <<_serial_peripheral_interface_controller_spi>> FIFO. Has to be a power of two, min 1, max 32768.
| `IO_SDI_EN`             | boolean   | false      | Implement the <<_serial_data_interface_controller_sdi>>.
| `IO_SDI_FIFO`           | natural   | 1          | Depth of the <<_serial_data_interface_controller_sdi>> FIFO. Has to be a power of two, min 1, max 32768.
| `IO_TWI_EN`             | boolean   | false      | Implement the <<_two_wire_serial_interface_controller_twi>>.
| `IO_PWM_NUM_CH`         | natural   | 0          | Number of channels of the <<_pulse_width_modulation_controller_pwm>> to implement (0..12).
| `IO_WDT_EN`             | boolean   | false      | Implement the <<_watchdog_timer_wdt>>.
| `IO_TRNG_EN`            | boolean   | false      | Implement the <<_true_random_number_generator_trng>>.
| `IO_TRNG_FIFO`          | natural   | 1          | Depth of the TRNG data FIFO. Has to be a power of two, min 1, max 32768.
| `IO_CFS_EN`             | boolean   | false      | Implement the <<_custom_functions_subsystem_cfs>>.
| `IO_CFS_CONFIG`         | suv(31:0) | 0x00000000 | "Conduit" generic to pass user-defined flags to the <<_custom_functions_subsystem_cfs>>.
| `IO_CFS_IN_SIZE`        | natural   | 32         | Size of the <<_custom_functions_subsystem_cfs>> input signal conduit (`cfs_in_i`).
| `IO_CFS_OUT_SIZE`       | natural   | 32         | Size of the <<_custom_functions_subsystem_cfs>> output signal conduit (`cfs_out_o`).
| `IO_NEOLED_EN`          | boolean   | false      | Implement the <<_smart_led_interface_neoled>>.
| `IO_NEOLED_TX_FIFO`     | natural   | 1          | TX FIFO depth of the the <<_smart_led_interface_neoled>>. Has to be a power of two, min 1, max 32768.
| `IO_GPTMR_EN`           | boolean   | false      | Implement the <<_general_purpose_timer_gptmr>>.
| `IO_XIP_EN`             | boolean   | false      | Implement the <<_execute_in_place_module_xip>>.
| `IO_ONE_EN`             | boolean   | false      | Implement the <<_one_wire_serial_interface_controller_onewire>>.
|=======================


<<<
// ####################################################################################################################
:sectnums:
=== Processor Clocking

The processor is implemented as fully-synchronous logic design using a single clock domain that is driven entirely by the
top's `clk_i` signal. This clock signal is used by all internal registers and memories, which trigger on the rising edge of
this clock signal. External "clocks" like the OCD's JTAG clock or the TWI's serial clock are synchronized into the
processor's clock domain before being further processed.

[NOTE]
Only the registers of the <<_processor_reset>> system trigger on a _falling_ clock edge.

Many processor modules like the UARTs or the timers require a programmable time base for operations. In order to simplify
the hardware, the processor implements a global "clock generator" that provides _clock enables_ for certain frequencies.
These clock enable signals are synchronous to the system's main clock and will be high for only a single cycle. Hence,
processor modules can use these enables for sub-main-clock operations while still having a single clock domain only.

In total, 8 sub-main-clock signals are available. All processor modules, which feature a time-based configuration, provide a
programmable three-bit prescaler select in their according control register to select one of the 8 available clocks. The
mapping of the prescaler select bits to the according clock source is shown in the table below. Here, _f_ represents the
processor main clock from the top entity's `clk_i` signal.

[cols="<3,^1,^1,^1,^1,^1,^1,^1,^1"]
[grid="rows"]
|=======================
| Prescaler bits:  | `0b000` | `0b001` | `0b010` | `0b011` | `0b100` | `0b101` | `0b110` | `0b111`
| Resulting clock: | _f/2_   | _f/4_   | _f/8_   | _f/64_  | _f/128_ | _f/1024_| _f/2048_| _f/4096_
|=======================

The software framework provides pre-defined aliases for the prescaler select bits:

.Prescaler Aliases from `neorv32.h`
[source,c]
--------------------------
enum NEORV32_CLOCK_PRSC_enum {
  CLK_PRSC_2    = 0, /**< CPU_CLK (from clk_i top signal) / 2 */
  CLK_PRSC_4    = 1, /**< CPU_CLK (from clk_i top signal) / 4 */
  CLK_PRSC_8    = 2, /**< CPU_CLK (from clk_i top signal) / 8 */
  CLK_PRSC_64   = 3, /**< CPU_CLK (from clk_i top signal) / 64 */
  CLK_PRSC_128  = 4, /**< CPU_CLK (from clk_i top signal) / 128 */
  CLK_PRSC_1024 = 5, /**< CPU_CLK (from clk_i top signal) / 1024 */
  CLK_PRSC_2048 = 6, /**< CPU_CLK (from clk_i top signal) / 2048 */
  CLK_PRSC_4096 = 7  /**< CPU_CLK (from clk_i top signal) / 4096 */
};
--------------------------

[TIP]
If no peripheral modules requires a clock signal from the internal generator (all available modules disabled by clearing the
enable bit in the according module's control register), it is automatically deactivated to reduce dynamic power consumption.



<<<
// ####################################################################################################################
:sectnums:
=== Processor Reset

.Processor Reset Signal
[IMPORTANT]
Always make sure to connect the processor's reset signal `rstn_i` to a valid reset source (a button, the "locked"
signal of a PLL, a dedicated reset controller, etc.).

The processor-wide reset can be triggered by any of the following sources:

* the asynchronous low-active `rstn_i` top entity input signal
* the <<_on_chip_debugger_ocd>>
* the <<_watchdog_timer_wdt>>

If any of these sources trigger a reset, the internal reset will be triggered for at least 4 clock cycles ensuring
a valid reset of the entire processor. The internal global reset is asserted _aysynchronoulsy_ if triggered by the external
`rstn_i` signal. For internal reset sources, the global reset is asserted _synchronously_. If the reset cause gets inactive
the internal reset is de-asserted _synchronously_ at a falling clock edge.

Internally, all processor registers that actually do provide a hardware reset use an **asynchronous reset**. An asynchronous
reset ensures that the entire processor logic is reset to a defined state even if the main clock is not yet operational.

In order to reduce routing constraints (and by this the actual hardware requirements), some _uncritical registers_
of the NEORV32 CPU as well as many registers of the entire NEORV32 Processor do not use a dedicated hardware reset.
For example there are several pipeline registers and "buffer" registers that do not require a defined
initial state to ensure correct operation.

[NOTE]
The system reset will only reset the control registers of each implemented IO/peripheral module. This control register
reset will also reset the according "module enable flag" to zero, which - in turn - will cause a _synchronous_
module-internal reset of the remaining logic.


<<<
// ####################################################################################################################
:sectnums:
=== Processor Interrupts

The NEORV32 Processor provides several interrupt request signals (IRQs) for custom platform use.


:sectnums:
==== RISC-V Standard Interrupts

The processor setup features the standard machine-level RISC-V interrupt lines for "machine timer interrupt", "machine
software interrupt" and "machine external interrupt". Their usage is defined by the RISC-V privileged architecture
specifications. However, bare-metal system can also repurpose these interrupts. See CPU section
<<_traps_exceptions_and_interrupts>> for more information.

[cols="<4,<10"]
[options="header",grid="rows"]
|=======================
| Top signal | Description
| `mtime_irq_i` | Machine timer interrupt from _processor-external_ MTIME unit (`MTI`). This IRQ is only available if the processor-internal <<_machine_system_timer_mtime>> unit is not implemented.
| `msw_irq_i`   | Machine software interrupt (`MSI`). This interrupt is used for inter-processor interrupts in multi-core systems. However, it can also be used for any custom purpose.
| `mext_irq_i`  | Machine external interrupt (`MEI`). This interrupt is used for any processor-external interrupt source (like a platform interrupt controller).
|=======================

.Trigger Type
[IMPORTANT]
The RISC-V standard interrupts are **level-triggered and high-active**. Once set, the signal has to remain high until
the interrupt request is explicitly acknowledged (e.g. writing to a memory-mapped register). The RISC-V standard interrupts
**CANNOT** be acknowledged/cleared by writing zero to the according <<_mip>> CSR bit.


:sectnums:
==== NEORV32-Specific Fast Interrupt Requests

As part of the NEORV32-specific CPU extensions, the processor core features 16 fast interrupt request signals
(`FIRQ0` - `FIRQ15`) providing dedicated bits in the <<_mip>> and <<_mie>> CSRs and custom <<_mcause>> trap codes.
The FIRQ signals are reserved for _processor-internal_ modules only (for example for the communication
interfaces to signal "available incoming data" or "ready to send new data").

The mapping of the 16 FIRQ channels to the according processor-internal modules is shown in the following
table (the channel number also corresponds to the according FIRQ priority: 0 = highest, 15 = lowest):

.NEORV32 Fast Interrupt Request (FIRQ) Mapping
[cols="^2,<8,<7"]
[options="header",grid="rows"]
|=======================
| Channel | Source | Description
| 0       | <<_watchdog_timer_wdt,WDT>> | watchdog timeout interrupt
| 1       | <<_custom_functions_subsystem_cfs,CFS>> | custom functions subsystem (CFS) interrupt (user-defined)
| 2       | <<_primary_universal_asynchronous_receiver_and_transmitter_uart0,UART0>> | Configurable UART0 RX interrupt
| 3       | <<_primary_universal_asynchronous_receiver_and_transmitter_uart0,UART0>> | Configurable UART0 TX interrupt
| 4       | <<_secondary_universal_asynchronous_receiver_and_transmitter_uart1,UART1>> | Configurable UART1 RX interrupt
| 5       | <<_secondary_universal_asynchronous_receiver_and_transmitter_uart1,UART1>> | Configurable UART1 TX interrupt
| 6       | <<_serial_peripheral_interface_controller_spi,SPI>> | Configurable SPI interrupt
| 7       | <<_two_wire_serial_interface_controller_twi,TWI>> | TWI transmission done interrupt
| 8       | <<_external_interrupt_controller_xirq,XIRQ>> | External interrupt controller interrupt
| 9       | <<_smart_led_interface_neoled,NEOLED>> | NEOLED TX buffer interrupt
| 10      | - | _reserved_
| 11      | <<_serial_data_interface_controller_sdi,SDI>> | Configurable SDI interrupt
| 12      | <<_general_purpose_timer_gptmr,GPTMR>> | General purpose timer interrupt
| 13      | <<_one_wire_serial_interface_controller_onewire,ONEWIRE>> | 1-wire operation done interrupt
| 14      | - | _reserved_
| 15      | - | _reserved_
|=======================

.Trigger Type
[IMPORTANT]
The fast interrupt request channels become pending after being triggering by one-cycle-high signal.
A pending FIRQ has to be explicitly cleared by writing zero to the according <<_mip>> CSR bit.


<<<
// ####################################################################################################################
:sectnums:
=== Address Space

As a 32-bit architecture the NEORV32 can access a 4GB physical address space. By default, this address space is
divided into five main regions:

1. **Instruction address space** for instructions (=code) and constants. A configurable section of this address space can used by the instruction memory (<<_instruction_memory_imem>>).
2. **Data address space** for application runtime data (heap, stack, etc.). A configurable section of this address space can be used by the data memory (<<_data_memory_dmem>>).
3. **Bootloader address space** for the internal bootloader memory <<_bootloader_rom_bootrom>>.
4. **On-Chip Debugger address space** for the processor's <<_on_chip_debugger_ocd>>.
5. **IO/peripheral address space**: for the processor-internal memory-mapped <<_processor_internal_modules>>.

.NEORV32 Processor Address Space (Default Configuration)
image::address_space.png[900]

.RAM Layout
[TIP]
The actual usage of the data address space by the software/executables (stack, heap, ...) is
illustrated in section <<_ram_layout>>.


:sectnums:
==== Physical Memory Attributes (PMAs)

Each default region of the NEORV32 address space provides specific physical memory attributes that define the allowed access types.
The according access permission are enforced by the hardware and cannot be changed. If an access violates the PMA's permissions an
exception is raised. The access permissions can be further constrained using the CPU's <<_pmp_isa_extension>>.

* `r` - data read access
* `w` - data write access
* `x` - instruction fetch access ("execute")

[cols="<1,^4,^2,<7"]
[options="header",grid="rows"]
|=======================
| # | Region Description             | PMAs    | Note
| 1 | Instruction address space      | `r(w)x` | Write accesses to the the internal <<_instruction_memory_imem>> can be disabled.
| 2 | Data address space             | `rwx`   | Code can also be executed from data memory.
| 3 | Bootloader address space       | `r-x`   | Read-only memory.
| 4 | On-Chip Debugger address space | `---`   | Not accessible at all by "normal" software - accessible only when the CPU is in <<_cpu_debug_mode>>.
| 5 | IO/peripheral address space    | `rw-`   | Read/write accesses only.
|=======================


:sectnums:
==== CPU Data and Instruction Access

The CPU can access all of the 32-bit address space from the instruction fetch interface (**I**) and also from the
data access interface (**D**). These two CPU interfaces are multiplexed by a simple bus switch
(`rtl/core/neorv32_busswitch.vhd`) into a single processor-internal bus. All processor-internal memories, peripherals
and also the external memory interface are connected to this bus. Hence, both CPU interfaces (instruction fetch & data access)
have access to the same (identical!) address space making the processor a **modified von-Neumann architecture**.

.Processor-internal bus architecture
image::neorv32_bus.png[1300]

[NOTE]
The internal processor bus might appear as bottleneck. In order to reduce traffic jam on this bus
(when instruction fetch and data interface access the bus at the same time) the instruction fetch of
the CPU is equipped with a prefetch buffer. Memory accesses can be further buffered using the caches.
Furthermore, data accesses (loads and stores) have higher priority than instruction fetch accesses.

[TIP]
See sections <<_architecture>> and <<_bus_interface>> for more information regarding the CPU bus accesses.


:sectnums:
==== Address Space Layout

The general address space layout consists of two main configuration constants: `ispace_base_c` defining
the base address of the _instruction memory address space_ and `dspace_base_c` defining the base address of
the _data memory address space_. Both constants are defined in the NEORV32 VHDL package file
`rtl/core/neorv32_package.vhd`:

[source,vhdl]
----
-- Architecture Configuration ----------------------------------------------------
-- ----------------------------------------------------------------------------------
constant ispace_base_c : std_ulogic_vector(31 downto 0) := x"00000000";
constant dspace_base_c : std_ulogic_vector(31 downto 0) := x"80000000";
----

The default configuration assumes the _instruction memory address space_ starting at address `0x00000000`
and the _data memory address space_ starting at `0x80000000`. Both values can be modified for a specific
setup and the address space may also overlap or can even be identical.


:sectnums:
==== Memory Configuration

The NEORV32 Processor was designed to provide maximum flexibility for the actual memory configuration.
The processor can populate the _instruction address space_ and/or the _data address space_ with **internal memories**
for instructions (IMEM) and data (DMEM). Processor **external memories** can be used as an alternative or even in
combination with the internal ones. The figure below show some exemplary memory configurations.

.Exemplary Memory Configurations
image::neorv32_memory_configurations.png[800]

[NOTE]
Any access to "address holes" (addresses that do not belong to a specific module) will raise a bus exception fault
due to the missing access acknowledge.


:sectnums!:
===== Internal Memories

If the processor-internal <<_instruction_memory_imem>> is implemented, it is located right at the base address of the instruction
address space (default `ispace_base_c` = _0x00000000_). Vice versa, the processor-internal <<_data_memory_dmem>> is
located right at the beginning of the data address space (default `dspace_base_c` = _0x80000000_) when implemented.


:sectnums!:
===== External Memories

Any CPU access (data or instructions), which does **not** fulfill at least one of the following conditions, is forwarded
via the <<_processor_external_memory_interface_wishbone>> to external components:

* access to the processor-internal <<_instruction_memory_imem>> and processor-internal IMEM is implemented
* access to the processor-internal <<_data_memory_dmem>> and processor-internal DMEM is implemented
* access to the processor-internal bootloader ROM and beyond

[NOTE]
If the <<_execute_in_place_module_xip>> is implemented accesses mapped to this module are not forwarded to the
external memory interface.

[NOTE]
If the <<_processor_external_memory_interface_wishbone>> is not implemented, any access exceeding the internal
memory address space will raise a bus access fault exception.


:sectnums:
==== Boot Configuration

Due to the flexible memory configuration, the NEORV32 Processor provides several different boot scenarios.
The following section illustrates the two most common boot scenarios.

.NEORV32 Boot Configurations
image::neorv32_boot_configurations.png[800]

There are two general boot scenarios: _Indirect Boot_ (1a and 1b) and _Direct Boot_ (2a and 2b) configured via the
`INT_BOOTLOADER_EN` generic. If this generic is `true` the _indirect boot scenario_ is used. This is also the
default boot configuration of the processor. If `INT_BOOTLOADER_EN` is `*false` the _direct boot scenario_ is used.

:sectnums!:
===== Indirect Boot

The indirect_boot scenarios **1a** and **1b** are based on the processor-internal <<_bootloader>>. This boot setup is enabled
by setting the `INT_BOOTLOADER_EN` generic to `true`, which will implement the processor-internal <<_bootloader_rom_bootrom>>.
This read-only memory is pre-initialized during synthesis with the default bootloader firmware. The bootloader provides several
options to upload an executable copying it to the beginning of the _instruction address space_ so the CPU can execute it.

Boot scenario **1a** uses the processor-internal IMEM. This scenario implements the internal <<_instruction_memory_imem>>
as non-initialized RAM so the bootloader can copy the actual executable to it.

Boot scenario **1b** uses a processor-external IMEM that is connected via the processor's bus interface. In this scenario
the internal <<_instruction_memory_imem>> is not implemented at all and the bootloader will copy the executable to the
processor-external memory. Hence, the external memory has to be implemented as RAM.

:sectnums!:
===== Direct Boot

The direct boot scenarios **2a** and **2b** do not use the processor-internal bootloader since the `INT_BOOTLOADER_EN`
generic is set `false`. In this configuration the <<_bootloader_rom_bootrom>> is not implemented at all and the CPU will
directly begin executing code from the beginning of the instruction address space after reset. An application-specific
"pre-initialization" mechanism is required in order to provide an executable inside the memory.

Boot scenario **2a** uses the processor-internal IMEM implemented as _read-only memory_ in this scenario.
It is pre-initialized (by the bitstream) with the actual application executable during synthesis.

In contrast, boot scenario **2b** uses a processor-external IMEM. In this scenario the system designer is responsible for
providing an initialized external memory that contains the actual application to be executed.


<<<
// ####################################################################################################################
:sectnums:
=== Processor-Internal Modules

The NEORV32 processor is a SoC (system-on-chip) consisting of the NEORV32 CPU, peripheral/IO devices, embedded
memories, an external memory interface and a bus infrastructure to interconnect all modules.

The processor-internal peripheral/IO devices are located at the end of the 32-bit address space at base
address `0xFFFFFE00`. A region of 512 bytes is reserved for these devices. Hence, all peripheral/IO devices are
accessed using a memory-mapped scheme.

.Module Address Space Mapping
[IMPORTANT]
The base address of each component/module has to be aligned to the total size of the module's occupied address space.
The occupied address space has to be a power of two (minimum 4 bytes). Addresses of peripheral modules must not overlap.

.Full-Word Write Accesses Only
[IMPORTANT]
All peripheral/IO devices can only be written in full-word mode (i.e. 32-bit). Byte or half-word (8/16-bit) write accesses
will raise a store access fault exception. Read accesses are not size constrained. Processor-internal memories as well as
modules connected to the external memory interface can be written with arbitrary granularity.

.Unimplemented Modules / "Address Holes"
[NOTE]
When accessing an IO device that hast not been implemented (disabled via the according generic)
or when accessing an address that is actually unused, a load or store access fault exception is raised.

.Module Interrupts
[NOTE]
Most peripheral/IO devices provide some kind of interrupt (for example to signal available incoming data). These
interrupts are entirely mapped to the CPU's <<_custom_fast_interrupt_request_lines>>.
See section <<_processor_interrupts>> for more information.

.CMSIS System Description View (SVD)
[TIP]
A CMSIS-SVD-compatible **System View Description (SVD)** file including all peripherals is available in `sw/svd`.


include::soc_imem.adoc[]

include::soc_dmem.adoc[]

include::soc_bootrom.adoc[]

include::soc_icache.adoc[]

include::soc_dcache.adoc[]

include::soc_wishbone.adoc[]

include::soc_buskeeper.adoc[]

include::soc_gpio.adoc[]

include::soc_wdt.adoc[]

include::soc_mtime.adoc[]

include::soc_uart.adoc[]

include::soc_spi.adoc[]

include::soc_sdi.adoc[]

include::soc_twi.adoc[]

include::soc_onewire.adoc[]

include::soc_pwm.adoc[]

include::soc_trng.adoc[]

include::soc_cfs.adoc[]

include::soc_neoled.adoc[]

include::soc_xirq.adoc[]

include::soc_gptmr.adoc[]

include::soc_xip.adoc[]

include::soc_sysinfo.adoc[]
